<!DOCTYPE html>
<html>
<head>
<style>
*{margin:0;padding:0;cursor:none}
body{background:#000;overflow:hidden}
canvas{display:block;width:100vw;height:100vh}
#h{position:fixed;top:10px;right:10px;z-index:2;user-select:none; color: #0f0; font: 20px monospace; text-shadow: 0 0 10px #0f0;}
#help-link {
    display: none;
    position: absolute;
    color: #0cf;
    font: 14px monospace;
    text-decoration: none;
    text-shadow: 0 0 10px #0cf;
    z-index: 3;
}
#help-link:hover {
    color: #fff;
    text-shadow: 0 0 15px #fff;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="h">?</div>
<a id="help-link" href="help.html" target="_blank">→ SEE FULL DOCUMENTATION</a>
<script>
const helpLink = document.getElementById('help-link');
// ===================
// STYLE CONFIGURATION
// ===================
const THEME = {
    colors: {
        background: '#000',
        default: '#0f0',
        selection: '#0ff',
        active: '#f90',
        sustain: '#0f0',
        sustainText: '#0f0',
        sustainShadow: '#0f0',
        innerSelection: '#0df',
        msgInactive: '#f00',
        msgActive: '#0f0',
        emptyNode: '#666',
        grid: 'rgba(0,255,0,0.05)',
        textKey: '#fff',
        editMode: '#f00',
        editModeText: '#0ff',
        previewFill: 'rgba(0, 204, 255, 0.05)',
        backgroundFade: 'rgba(0,0,0,0.08)',
        helpLinkHover: '#fff',
        helpText: '#0f0',
        helpTextHighlight: '#0cf'
    },
    fonts: {
        helpButton: '20px monospace',
        connectionMsg: 'bold 24px monospace',
        docLink: '14px monospace',
        nodeKey: 'bold 20px monospace',
        nodeHz: '12px monospace',
        cursorHz: '15px monospace',
        editMode: '18px monospace',
        previewStatus: '15px monospace',
        playingStatus: '15px monospace',
        listStatus: '20px monospace',
        allKeys: '15px monospace',
        helpFont: '14px monospace'
    },
    shadows: {
        blurDefault: 2,
        blurNode: 15,
        blurNodeActive: 30,
        blurNodeSelected: 15,
        blurConnectionMsg: 30,
        blurHelp: 0.25
    }
};


// Setup
const a=new AudioContext(),
A=a.createAnalyser(),
g=a.createGain(),
c=document.getElementById('c'),
x=c.getContext('2d');

let W=c.width=innerWidth,
H=c.height=innerHeight;

// Apply initial styles from THEME object
document.body.style.backgroundColor = THEME.colors.background;
const hDiv = document.getElementById('h');
hDiv.style.color = THEME.colors.default;
hDiv.style.font = THEME.fonts.helpButton;
hDiv.style.textShadow = `0 0 ${THEME.shadows.blurDefault}px ${THEME.colors.default}`;


A.fftSize=2048;
g.connect(A);
A.connect(a.destination);
g.gain.value=0.3;

// State
const o={}, m={}, p={}, s={}, e={}, sel={},
      d=new Uint8Array(A.frequencyBinCount);

const EDIT_MODES = ['OSC', 'ADSR', 'FILTER', 'FX', 'MOD'];
const OSC_TYPES=['sine','triangle','square','sawtooth'];
const ADSR_PARAMS = ['ATTACK', 'DECAY', 'SUSTAIN', 'RELEASE'];
const FILTER_TYPES = ['lowpass', 'highpass', 'bandpass', 'notch'];
const FX_PARAMS = ['DISTORT', 'REVERB', 'ECHO_MIX', 'ECHO_FDBK', 'TREMOLO', 'PAN'];
const MOD_TARGETS = ['FILTER', 'PITCH'];

let mx=W/2,my=H/2,t=0,hk=null,md=0,pv=null,pk=new Set(),esc=0,ei=0,help=0,
    drag=null,dragOff={x:0,y:0}, editModeIndex = 0, adsrParamIndex = 0, fxParamIndex = 0, modParamIndex = 0,
    heldKeys = {}, lastIncrementTime = 0, audioReady = false, connectionMsg = 'Click to Connect';

// Impulse Response for Convolver
let impulseBuffer;
(async function createImpulse() {
    const sampleRate = a.sampleRate;
    const length = sampleRate * 1.5;
    impulseBuffer = a.createBuffer(2, length, sampleRate);
    const impulseL = impulseBuffer.getChannelData(0);
    const impulseR = impulseBuffer.getChannelData(1);
    for (let i = 0; i < length; i++) {
        const decay = Math.pow(1 - i / length, 2.5);
        impulseL[i] = (Math.random() * 2 - 1) * decay;
        impulseR[i] = (Math.random() * 2 - 1) * decay;
    }
})();


// Handle resize
onresize=()=>{
  const relPos={};
  Object.keys(p).forEach(k=>{ relPos[k]={x:p[k].x/W,y:p[k].y/H}; });
  const relEmpty={};
  Object.keys(e).forEach(k=>{ relEmpty[k]={x:e[k].x/W,y:e[k].y/H}; });

  W=c.width=innerWidth; H=c.height=innerHeight;

  Object.keys(relPos).forEach(k=>{
    p[k]={...p[k], x:relPos[k].x*W, y:relPos[k].y*H};
    m[k]=F(p[k].x,p[k].y);
  });
  Object.keys(relEmpty).forEach(k=>{
    e[k]={x:relEmpty[k].x*W,y:relEmpty[k].y*H,f:F(relEmpty[k].x*W,relEmpty[k].y*H)};
  });

  mx=mx/innerWidth*W; my=my/innerHeight*H;
};

// Calculate frequency
const F=(x,y)=>Math.pow(2,(x/W*4))*55*Math.pow(2,1-y/H*3);

// ===================
// AUDIO NODE CREATION
// ===================

function makeDistortionCurve(amount) {
  const k = typeof amount === 'number' ? amount : 50;
  const n_samples = 44100;
  const curve = new Float32Array(n_samples);
  const deg = Math.PI / 180;
  for (let i = 0; i < n_samples; ++i) {
    const x = i * 2 / n_samples - 1;
    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
  }
  return curve;
};

const createAudioNodes=(f,x,y, nodeProps)=>{
  const now = a.currentTime;
  const np = nodeProps;

  const v = a.createGain();
  v.gain.setValueAtTime(0, now);

  const osc = a.createOscillator();
  osc.frequency.value = f;
  osc.type = np.type || 'sine';

  const filter = a.createBiquadFilter();
  filter.type = np.filterType || 'lowpass';
  filter.frequency.value = np.filterFreq || 20000;
  filter.Q.value = np.filterQ || 1;

  const distortion = a.createWaveShaper();
  distortion.curve = makeDistortionCurve(np.distortionAmount || 0);
  distortion.oversample = '4x';
  
  const convolver = a.createConvolver();
  convolver.buffer = impulseBuffer;
  const reverbWet = a.createGain();
  reverbWet.gain.value = np.reverbWet || 0;
  
  const delay = a.createDelay(1.0);
  delay.delayTime.value = 0.5;
  const feedback = a.createGain();
  feedback.gain.value = np.echoFeedback || 0;
  const echoMix = a.createGain();
  echoMix.gain.value = np.echoMix || 0;

  const tremoloLFO = a.createOscillator();
  tremoloLFO.frequency.value = 5;
  const tremoloDepth = a.createGain();
  tremoloDepth.gain.value = np.tremoloDepth || 0;
  tremoloLFO.connect(tremoloDepth);
  tremoloDepth.connect(v.gain);
  tremoloLFO.start();

  const modLFO = a.createOscillator();
  modLFO.frequency.value = np.lfoRate || 5;
  const modDepth = a.createGain();
  modDepth.gain.value = np.lfoDepth || 0;
  modLFO.connect(modDepth);
  const modTarget = np.lfoTarget || 'FILTER';
  if (modTarget === 'FILTER') modDepth.connect(filter.frequency);
  else if (modTarget === 'PITCH') modDepth.connect(osc.frequency);
  modLFO.start();

  const panner = a.createStereoPanner();
  panner.pan.value = np.pan || (x / W - 0.5) * 2;

  osc.connect(filter);
  filter.connect(distortion);
  const lastNode = distortion;

  lastNode.connect(panner);
  lastNode.connect(convolver).connect(reverbWet).connect(panner);
  lastNode.connect(delay);
  delay.connect(feedback);
  feedback.connect(delay);
  delay.connect(echoMix);
  echoMix.connect(panner);
  
  panner.connect(v);
  v.connect(g);
  osc.start();

  const attack = np.attack || 0.01;
  const decay = np.decay || 0.1;
  const sustain = np.sustain || 0.5;
  v.gain.linearRampToValueAtTime(1, now + attack);
  v.gain.linearRampToValueAtTime(sustain, now + attack + decay);
  
  return {s:osc,v,p:panner,f,filter,distortion,reverbWet,delay,feedback,echoMix,tremoloDepth, modLFO, modDepth};
};

const stopOsc=(osc, releaseTime = 0.5)=>{
  if(!osc || !osc.v) return;
  const now = a.currentTime;
  osc.v.gain.cancelScheduledValues(now);
  osc.v.gain.setValueAtTime(osc.v.gain.value, now);
  osc.v.gain.linearRampToValueAtTime(0.0001, now + releaseTime);
  setTimeout(()=>{
      if (osc.s) {
        osc.s.stop();
        osc.s.disconnect();
      }
    }, (releaseTime + 0.1) * 1000);
};

const stopAll = () => {
    Object.keys(o).forEach(k => {
        if (o[k]) {
            stopOsc(o[k], p[k]?.release || 0.1);
            delete o[k];
        }
    });
    Object.keys(s).forEach(k => delete s[k]);
};


// ===================
// MOUSE CONTROLS
// ===================

onmousemove=e=>{
  mx=e.clientX;
  my=e.clientY;

  if(drag){
    Object.keys(sel).forEach(k=>{
        if(sel[k] && p[k]){
            let newX, newY;
            if(k === drag){ newX = mx; newY = my; } 
            else {
                const offset = dragOff.nodes[k];
                newX = offset ? mx + offset.x : p[k].x;
                newY = offset ? my + offset.y : p[k].y;
            }
            p[k].x = newX; p[k].y = newY; m[k] = F(newX, newY);
            if(o[k] && o[k].s){
                o[k].s.frequency.exponentialRampToValueAtTime(m[k], a.currentTime + 0.05);
                o[k].p.pan.value = p[k].pan || (newX / W - 0.5) * 2;
            }
        }
    });
    return;
  }

  if(hk&&o[hk]&&!o[hk].assigned){
    const f=F(mx,my);
    o[hk].s.frequency.exponentialRampToValueAtTime(f,a.currentTime+0.05);
    o[hk].p.pan.value=(mx/W-0.5)*2;
    o[hk].f=f; o[hk].mx=mx; o[hk].my=my;
  }

  if(md&&pv){
    const f=F(mx,my);
    pv.s.frequency.exponentialRampToValueAtTime(f,a.currentTime+0.05);
    pv.p.pan.value=(mx/W-0.5)*2;
    pv.mx=mx; pv.my=my; pv.f=f;
  }
};

onmousedown=e=>{
  if (!audioReady) {
    a.resume();
    audioReady = true;
    connectionMsg = null;
  }

  if(e.button===2)return;
  mx=e.clientX; my=e.clientY;
  if(help){
    const hx=W/2, hy=H/2-140, docLine=15, lineY=hy+docLine*25;
    const docText='→ DOCUMENTATION: help.html';
    x.font = THEME.fonts.docLink;
    x.textAlign='center';
    const tw=x.measureText(docText).width;
    x.textAlign='left';
    if(mx>hx-tw/2&&mx<hx+tw/2&&my>lineY-10&&my<lineY+10){ window.open('help.html','_blank'); return; }
    help=false; return;
  }

  let clicked=false;
  Object.keys(p).forEach(k=>{
    const {x:kx,y:ky}=p[k];
    if(Math.sqrt((mx-kx)**2+(my-ky)**2)<25){
      clicked=true;
      if(!sel[k]&&!e.shiftKey&&!e.ctrlKey&&!e.metaKey){ Object.keys(sel).forEach(sk=>delete sel[sk]); }
      sel[k]=true;
      drag=k;
      dragOff={x:mx,y:my,nodes:{}};
      Object.keys(sel).forEach(sk=>{
        if(sel[sk] && sk!==k && p[sk]){ dragOff.nodes[sk]={x:p[sk].x-mx,y:p[sk].y-my}; }
      });
    }
  });

  if(!clicked){
    Object.keys(e).forEach(id=>{
      const {x:ex,y:ey}=e[id];
      if(Math.sqrt((mx-ex)**2+(my-ey)**2)<25){ clicked=true; delete e[id]; }
    });
  }

  if(!clicked){
    if(!e.shiftKey&&!e.ctrlKey&&!e.metaKey){ Object.keys(sel).forEach(k=>delete sel[k]); }
    md=1;
    const f=F(mx,my);
    const audioNodes=createAudioNodes(f,mx,my, {});
    pv={...audioNodes,mx,my,f};
  }
};

onmouseup=e=>{
  if(e.button===2)return;
  if(drag){ drag=null; dragOff={x:0,y:0}; return; }
  md=0;
  if(pv&&!pv.assigned){
    const emptyKeys=Object.keys(e);
    if(emptyKeys.length>0&&!pv.wasKey){ e[emptyKeys[emptyKeys.length-1]]={x:pv.mx,y:pv.my,f:F(pv.mx,pv.my)}; }
    else{ e['e'+(ei++)]={x:pv.mx,y:pv.my,f:F(pv.mx,pv.my)}; }
    if(!pv.keepAlive){ stopOsc(pv,0.2); pv=null; }
  }else if(pv&&!pv.keepAlive){ stopOsc(pv,0.2); pv=null; }
};

oncontextmenu=e=>{
  e.preventDefault();
  Object.keys(p).forEach(k=>{
    const {x:kx,y:ky}=p[k];
    if(Math.sqrt((e.clientX-kx)**2+(e.clientY-ky)**2)<25){
      if(o[k]){ stopOsc(o[k],0.1); delete o[k]; }
      delete m[k]; delete p[k]; delete s[k]; delete sel[k];
    }
  });
};

// ===================
// KEYBOARD & MOUSEWHEEL CONTROLS
// ===================

function handleValueChange(direction, isScroll = false) {
    const selKeys=Object.keys(sel).filter(key => sel[key]);
    if (selKeys.length === 0) return;

    const currentEditMode = EDIT_MODES[editModeIndex];

    if (currentEditMode === 'FILTER') {
        selKeys.forEach(key => {
            if(p[key]){
                let currentFreq = p[key].filterFreq || 20000;
                currentFreq *= (direction > 0 ? 1.1 : 1/1.1);
                p[key].filterFreq = Math.max(20, Math.min(20000, currentFreq));
                if(o[key]) o[key].filter.frequency.linearRampToValueAtTime(p[key].filterFreq, a.currentTime + 0.02);
            }
        });
    } else if (currentEditMode === 'OSC') {
        selKeys.forEach(key => {
            if(p[key]){ p[key].vol = Math.max(0, Math.min(1, (p[key].vol||0.4) + direction * 0.01)); if(o[key]) o[key].v.gain.linearRampToValueAtTime(p[key].vol, a.currentTime + 0.02); }
        });
    } else if (currentEditMode === 'ADSR') {
        const param = ADSR_PARAMS[adsrParamIndex];
        selKeys.forEach(key => {
            if(!p[key]) return;
            if(param === 'ATTACK') p[key].attack = Math.max(0.001, (p[key].attack || 0.01) + direction * 0.01);
            else if(param === 'DECAY') p[key].decay = Math.max(0.001, (p[key].decay || 0.1) + direction * 0.01);
            else if(param === 'SUSTAIN') p[key].sustain = Math.max(0, Math.min(1, (p[key].sustain || 0.5) + direction * 0.01));
            else if(param === 'RELEASE') p[key].release = Math.max(0.001, (p[key].release || 0.5) + direction * 0.01);
        });
    } else if (currentEditMode === 'FX') {
        const param = FX_PARAMS[fxParamIndex];
        selKeys.forEach(key => {
            if(!p[key]) return;
            if(param === 'DISTORT'){
                p[key].distortionAmount = Math.max(0, Math.min(1000, (p[key].distortionAmount || 0) + direction * 5));
                if(o[key]) o[key].distortion.curve = makeDistortionCurve(p[key].distortionAmount);
            } else if (param === 'REVERB') {
                p[key].reverbWet = Math.max(0, Math.min(1, (p[key].reverbWet || 0) + direction * 0.02));
                if(o[key]) o[key].reverbWet.gain.linearRampToValueAtTime(p[key].reverbWet, a.currentTime + 0.02);
            } else if (param === 'ECHO_MIX') {
                p[key].echoMix = Math.max(0, Math.min(1, (p[key].echoMix || 0) + direction * 0.02));
                if(o[key]) o[key].echoMix.gain.linearRampToValueAtTime(p[key].echoMix, a.currentTime + 0.02);
            } else if (param === 'ECHO_FDBK') {
                p[key].echoFeedback = Math.max(0, Math.min(0.95, (p[key].echoFeedback || 0) + direction * 0.02));
                if(o[key]) o[key].feedback.gain.linearRampToValueAtTime(p[key].echoFeedback, a.currentTime + 0.02);
            } else if (param === 'TREMOLO') {
                p[key].tremoloDepth = Math.max(0, Math.min(1, (p[key].tremoloDepth || 0) + direction * 0.02));
                if(o[key]) o[key].tremoloDepth.gain.linearRampToValueAtTime(p[key].tremoloDepth * (p[key].vol || 0.4), a.currentTime + 0.02);
            } else if (param === 'PAN') {
                p[key].pan = Math.max(-1, Math.min(1, (p[key].pan || 0) + direction * 0.05));
                if(o[key]) o[key].p.pan.linearRampToValueAtTime(p[key].pan, a.currentTime + 0.02);
            }
        });
    } else if (currentEditMode === 'MOD') {
        if (isScroll) {
            selKeys.forEach(key => {
                if(p[key]) {
                    p[key].lfoRate = Math.max(0.1, (p[key].lfoRate || 5) + direction * 0.5);
                    if(o[key]) o[key].modLFO.frequency.linearRampToValueAtTime(p[key].lfoRate, a.currentTime + 0.02);
                }
            });
        } else {
            selKeys.forEach(key => {
                if(p[key]) {
                    p[key].lfoDepth = Math.max(0, (p[key].lfoDepth || 0) + direction * 5);
                    if(o[key]) o[key].modDepth.gain.linearRampToValueAtTime(p[key].lfoDepth, a.currentTime + 0.02);
                }
            });
        }
    }
}

onwheel = e => {
    e.preventDefault();
    handleValueChange(e.deltaY < 0 ? 1 : -1, true);
};

onkeydown=e=>{
  const k=e.key;
  if(e.repeat && (k === 'ArrowUp' || k === 'ArrowDown')) {
  } else if (e.repeat) {
      return;
  }

  if (k === 'ArrowUp' || k === 'ArrowDown') {
      if (!heldKeys[k]) {
          heldKeys[k] = true;
          handleValueChange(k === 'ArrowUp' ? 1 : -1);
      }
      return;
  }

  if (m[k] && md && pv) {
      if (o[k]) { stopOsc(o[k], p[k] ? p[k].release : 0.5); delete o[k]; }
      p[k].x = mx; p[k].y = my; m[k] = F(mx, my);
      pv.assigned = true; pv.keepAlive = false;
      stopOsc(pv, 0.05); pv = null;
      pk.add(k); return;
  }

  if((e.ctrlKey||e.metaKey)&&k==='a'){ e.preventDefault(); Object.keys(p).forEach(key=>{ sel[key]=true; }); return; }
  if(k === 'Tab') { e.preventDefault(); editModeIndex = (editModeIndex + 1) % EDIT_MODES.length; return; }
  
  const selKeys=Object.keys(sel).filter(key => sel[key]);
  if(selKeys.length){
    let changed = false;
    const currentEditMode = EDIT_MODES[editModeIndex];
    const direction = k === 'ArrowRight' ? 1 : -1;

    if (currentEditMode === 'FILTER' && (k === 'ArrowLeft' || k === 'ArrowRight')) {
        selKeys.forEach(key => { if(p[key]){ const i = FILTER_TYPES.indexOf(p[key].filterType||'lowpass'); p[key].filterType=FILTER_TYPES[(i+direction+FILTER_TYPES.length)%FILTER_TYPES.length]; if(o[key])o[key].filter.type=p[key].filterType; }});
        changed = true;
    } else if (currentEditMode === 'OSC' && (k === 'ArrowLeft' || k === 'ArrowRight')) {
        selKeys.forEach(key => { if(p[key]){ const i = OSC_TYPES.indexOf(p[key].type||'sine'); p[key].type=OSC_TYPES[(i+direction+OSC_TYPES.length)%OSC_TYPES.length]; if(o[key])o[key].s.type=p[key].type; }});
        changed = true;
    } else if (currentEditMode === 'ADSR' && (k === 'ArrowLeft' || k === 'ArrowRight')) {
        adsrParamIndex = (adsrParamIndex + direction + ADSR_PARAMS.length) % ADSR_PARAMS.length;
        changed = true;
    } else if (currentEditMode === 'FX' && (k === 'ArrowLeft' || k === 'ArrowRight')) {
        fxParamIndex = (fxParamIndex + direction + FX_PARAMS.length) % FX_PARAMS.length;
        changed = true;
    } else if (currentEditMode === 'MOD' && (k === 'ArrowLeft' || k === 'ArrowRight')) {
        selKeys.forEach(key => { if(p[key]){ const i = MOD_TARGETS.indexOf(p[key].lfoTarget||'FILTER'); p[key].lfoTarget=MOD_TARGETS[(i+direction+MOD_TARGETS.length)%MOD_TARGETS.length]; if(o[key]){ /* Re-routing needed */ } }});
        changed = true;
    }
    if(changed) { e.preventDefault(); return; }
  }

  if(k==='?'||k==='/'){ e.preventDefault(); help=!help; return; }
  if(k==='Escape'){ e.preventDefault(); esc=1; stopAll(); Object.keys(sel).forEach(k=>delete sel[k]); return; }

  if(k===' '||k==='Space'){
    e.preventDefault();
    if(hk&&o[hk]&&!o[hk].assigned){
      m[hk]=o[hk].f;
      p[hk]={x:o[hk].mx||mx,y:o[hk].my||my};
      o[hk].assigned=true; s[hk]=true; hk=null; return;
    }
    const keysToToggle = selKeys.length ? selKeys : Object.keys(p).filter(key => Math.sqrt((mx-p[key].x)**2+(my-p[key].y)**2)<25);
    if (keysToToggle.length === 0) { pk.forEach(key => { if(m[key]) keysToToggle.push(key) }) }
    
    keysToToggle.forEach(key=>{
      if(s[key]){ delete s[key]; if(o[key]){ stopOsc(o[key], p[key].release || 0.5); delete o[key]; } }
      else{ s[key]=true; if(!o[key]){ const audioNodes=createAudioNodes(m[key],p[key].x,p[key].y, p[key]); o[key]={...audioNodes,assigned:true}; } }
    });
    return;
  }

  if(k==='Backspace'){
    e.preventDefault();
    if(esc){ stopAll(); Object.keys(m).forEach(k=>delete m[k]); Object.keys(p).forEach(k=>delete p[k]); Object.keys(e).forEach(k=>delete e[k]); Object.keys(s).forEach(k=>delete s[k]); Object.keys(sel).forEach(k=>delete sel[k]); return; }
    const keysToDelete = selKeys.length ? selKeys : [...pk];
    if (keysToDelete.length > 0) {
        keysToDelete.forEach(key=>{
            if(o[key]){ stopOsc(o[key],0.1); delete o[key]; }
            delete m[key]; delete p[key]; delete s[key]; delete sel[key];
        });
    } else { Object.keys(e).forEach(id=>delete e[id]); }
    return;
  }

  const isAlphaNum=/^[a-zA-Z0-9]$/.test(k);
  if(!isAlphaNum)return;

  pk.add(k);

  let filled=false;
  Object.keys(e).forEach(id=>{
    if(!filled){
      const {x:ex,y:ey,f}=e[id];
      if(Math.sqrt((mx-ex)**2+(my-ey)**2)<25){
        filled=true; m[k]=f;
        p[k]={x:ex,y:ey};
        delete e[id];
        const audioNodes=createAudioNodes(f,ex,ey,p[k]);
        o[k]={...audioNodes,assigned:true};
      }
    }
  });
  if(filled)return;

  if(md&&pv){
    m[k]=F(mx,my);
    p[k]={x:mx,y:my};
    pv.assigned=true; pv.keepAlive=true;
    return;
  }

  if(m[k]){
    sel[k] = true;
    if(!o[k]){
      const audioNodes=createAudioNodes(m[k],p[k].x,p[k].y, p[k]);
      o[k]={...audioNodes,assigned:true};
    }
  }else{
    if(!o[k]){
      hk=k; const f=F(mx,my);
      const audioNodes=createAudioNodes(f,mx,my,{});
      o[k]={...audioNodes,assigned:false,mx,my,f};
    }
  }
};

onkeyup=e=>{
  const k=e.key;
  if (k === 'ArrowUp' || k === 'ArrowDown') {
      delete heldKeys[k];
      return;
  }
  if(k==='Escape'){esc=0;return;}
  if(k===' '||k==='Space'||k==='Backspace'||k==='?'||k==='/'||k.includes('Arrow')||k==='Tab')return;
  delete sel[k]; pk.delete(k);

  if(pv&&pv.keepAlive&&pv.assigned){
    const audioNodes=createAudioNodes(pv.f,pv.mx,pv.my, p[k]);
    o[k]={...audioNodes,assigned:true};
    stopOsc(pv,0.1); pv=null;
  }

  if(o[k]){
    if(!o[k].assigned){
      m[k]=o[k].f;
      p[k]={x:o[k].mx||mx,y:o[k].my||my};
    }
    if(!s[k]){ stopOsc(o[k], p[k].release || 0.5); delete o[k]; }
    if(hk===k)hk=null;
  }
};

document.getElementById('h').onclick=()=>{ help=!help; };

// ===================
// RENDER LOOP
// ===================

function r(){
  const now = Date.now();
  if (now - lastIncrementTime > 50) {
      if (heldKeys['ArrowUp']) handleValueChange(1);
      if (heldKeys['ArrowDown']) handleValueChange(-1);
      if (heldKeys['ArrowUp'] || heldKeys['ArrowDown']) lastIncrementTime = now;
  }

  requestAnimationFrame(r);
  A.getByteTimeDomainData(d);
  
  if (md) {
      x.fillStyle = THEME.colors.previewFill;
      x.fillRect(0,0,W,H);
  }
  
  x.fillStyle=THEME.colors.backgroundFade;
  x.fillRect(0,0,W,H);

  x.strokeStyle=THEME.colors.grid; x.lineWidth=1;
  for(let i=1;i<10;i++){ x.beginPath(); x.moveTo(i*W/10,0); x.lineTo(i*W/10,H); x.stroke(); }
  for(let i=1;i<8;i++){ x.beginPath(); x.moveTo(0,i*H/8); x.lineTo(W,i*H/8); x.stroke(); }

  if(!audioReady || connectionMsg) {
      x.font = THEME.fonts.connectionMsg;
      x.textAlign = 'center';
      x.fillStyle = connectionMsg === 'Connected' ? THEME.colors.msgActive : THEME.colors.msgActive;
      x.shadowColor = x.fillStyle;
      x.shadowBlur = THEME.shadows.blurConnectionMsg;
      x.fillText(connectionMsg, W/2, H/2);
      x.shadowBlur = 0;
  }
  
  if(!help && audioReady){
    Object.keys(e).forEach(id=>{
      const {x:ex,y:ey,f}=e[id];
      x.strokeStyle = THEME.colors.emptyNode;
      x.shadowBlur = THEME.shadows.blurDefault;
      x.shadowColor = THEME.colors.emptyNode;
      x.lineWidth=1; x.setLineDash([5,5]);
      x.beginPath(); x.arc(ex,ey,15,0,Math.PI*2); x.stroke(); x.setLineDash([]);
      x.fillStyle = THEME.colors.emptyNode;
      x.font = THEME.fonts.nodeHz;
      x.textAlign='left'; x.fillText(~~f+'Hz',ex+20,ey+3);
    });

    Object.keys(p).forEach(k=>{
      const {x:kx,y:ky}=p[k];
      const active=o[k]&&o[k].assigned;
      const selected=sel[k];
      const sustained=s[k];

      let color = THEME.colors.default;
      if (selected) color = THEME.colors.selection;
      if (sustained) color = THEME.colors.sustain;

      const baseRadius = 15, baseLineWidth = 2;
      let radius = baseRadius, lineWidth = baseLineWidth, shadowBlur = THEME.shadows.blurNode;
      if (active) { shadowBlur = THEME.shadows.blurNodeActive; radius = baseRadius + 2 + Math.sin(t * 6) * 2; lineWidth = baseLineWidth + 1; }
      if (selected) { shadowBlur = THEME.shadows.blurNodeSelected; lineWidth = baseLineWidth + 3; }
      
      x.strokeStyle = color; x.fillStyle = color; x.shadowBlur = shadowBlur; x.shadowColor = color; x.lineWidth = lineWidth;
      x.beginPath(); x.arc(kx, ky, radius, 0, Math.PI * 2); x.stroke();
      x.beginPath(); x.arc(kx, ky, active ? 1 : 3, 0, Math.PI * 2); x.fill();
      
      if ((selected && active) || (selected && sustained)) {
          x.strokeStyle = THEME.colors.innerSelection;
          x.lineWidth = 2;
          x.shadowBlur = THEME.shadows.blurNode;
          x.shadowColor = x.strokeStyle;
          x.beginPath();
          x.arc(kx, ky, baseRadius * 0.75, 0, Math.PI * 2);
          x.stroke();
      }

      x.fillStyle = THEME.colors.textKey;
      x.font = THEME.fonts.nodeKey;
      x.textAlign='center'; x.textBaseline='middle';
      x.fillText(k.toUpperCase(),kx,ky);
      x.fillStyle=color; x.font=THEME.fonts.nodeHz; x.textAlign='left';
      x.fillText(~~m[k]+'Hz',kx+25,ky+3);
    });
  }

  const cf=F(mx,my);
  x.shadowBlur = THEME.shadows.blurDefault;
  x.lineWidth=1;
  let cursorColor = THEME.colors.default;
  if(drag || hk || md){
    cursorColor = THEME.colors.selection;
  }
  x.strokeStyle = cursorColor;
  x.shadowColor = cursorColor;
  
  if (hk || md) {
      x.shadowBlur=THEME.shadows.blurNodeActive; x.lineWidth=2;
      x.beginPath(); x.arc(mx,my, 15,0,Math.PI*2); x.stroke();
      x.beginPath(); x.arc(mx,my,8,0,Math.PI*2); x.stroke();
  } else {
      x.beginPath(); x.moveTo(mx-15,my); x.lineTo(mx+15,my); x.moveTo(mx,my-15); x.lineTo(mx,my+15); x.stroke();
  }

  if(audioReady && !help) {
    x.fillStyle=THEME.colors.default; x.font=THEME.fonts.cursorHz; x.textAlign='left'; x.fillText(~~cf+'Hz',mx+20,my-20);
    x.strokeStyle=THEME.colors.default; x.lineWidth=2; x.shadowBlur=THEME.shadows.blurNode; x.shadowColor=THEME.colors.default;
    x.beginPath();
    const l=d.length;
    for(let i=0;i<l;i++){ const v=d[i]/128, y=v*H/2, X=i/l*W; i?x.lineTo(X,y):x.moveTo(X,y); }
    x.stroke();
  }

  t+=0.015; const sx=t%1*W;
  x.strokeStyle=THEME.colors.default; x.shadowBlur=THEME.shadows.blurNodeActive; x.shadowColor=THEME.colors.default; x.globalAlpha=0.5; x.lineWidth=1;
  x.beginPath(); x.moveTo(sx,0); x.lineTo(sx,H); x.stroke(); x.globalAlpha=1;

  let y=H-20;
  
  const currentEditMode = EDIT_MODES[editModeIndex];

  if(!audioReady) {
     x.shadowColor = THEME.colors.editMode; 
  } else {
    x.font = THEME.fonts.editMode;
    x.fillStyle = THEME.colors.default;
    x.fillText(`EDIT MODE: ${currentEditMode}`, 10, y); y -= 20;
  }
  
  if(hk){ x.fillStyle=THEME.colors.active; x.shadowColor=THEME.colors.active; x.font=THEME.fonts.playingStatus; x.fillText('▶ '+hk.toUpperCase()+' : '+~~o[hk].f+'Hz',10,y); y-=20; }
  //if(md&&pv){ x.fillStyle=THEME.colors.selection; x.shadowColor=THEME.colors.selection; x.font=THEME.fonts.previewStatus; x.fillText(+~~cf+'Hz',10,y); y-=20; }
  
  const selKeys=Object.keys(sel).filter(k => sel[k]);
  if(selKeys.length){
    x.fillStyle=THEME.colors.default; x.shadowColor=THEME.colors.default; x.font=THEME.fonts.listStatus;
    let selText = 'Selected: ' + selKeys.map(k=>k.toUpperCase()).join(' ');
    const node = p[selKeys[0]]; // Use the first selected node as the reference for display.
    if(node){ // FIX: Display details even if more than one node is selected.
        if (currentEditMode === 'OSC') {
            selText += ` (${(node.type || 'sine').toUpperCase()} | Vol: ${~~((node.vol || 0.4) * 100)}%)`;
        } else if (currentEditMode === 'ADSR') {
            const param = ADSR_PARAMS[adsrParamIndex];
            let val = '';
            if(param === 'ATTACK') val = `${(node.attack || 0.01).toFixed(2)}s`;
            else if(param === 'DECAY') val = `${(node.decay || 0.1).toFixed(2)}s`;
            else if(param === 'SUSTAIN') val = `${~~((node.sustain || 0.5) * 100)}%`;
            else if(param === 'RELEASE') val = `${(node.release || 0.5).toFixed(2)}s`;
            selText += ` (ADSR: ${param} @ ${val})`;
        } else if (currentEditMode === 'FILTER') {
            selText += ` (Filter: ${(node.filterType || 'lowpass').toUpperCase()} @ ${~~node.filterFreq || 20000}Hz)`;
        } else if (currentEditMode === 'FX') {
            const param = FX_PARAMS[fxParamIndex];
            let val = '';
            if(param === 'DISTORT') val = `${~~((node.distortionAmount || 0)/10)}%`;
            else if(param === 'REVERB') val = `${~~((node.reverbWet || 0) * 100)}%`;
            else if(param === 'ECHO_MIX') val = `${~~((node.echoMix || 0) * 100)}%`;
            else if(param === 'ECHO_FDBK') val = `${~~((node.echoFeedback || 0) * 100)}%`;
            else if(param === 'TREMOLO') val = `${~~((node.tremoloDepth || 0) * 100)}%`;
            else if(param === 'PAN') val = `${~~((node.pan || 0) * 100)}%`;
            selText += ` (FX: ${param} @ ${val})`;
        } else if (currentEditMode === 'MOD') {
            const target = node.lfoTarget || 'FILTER';
            const rate = (node.lfoRate || 5).toFixed(1);
            const depth = (node.lfoDepth || 0).toFixed(0);
            selText += ` (LFO: ${target} | Rate: ${rate}Hz | Depth: ${depth})`;
        }
    }
    x.fillText(selText,10,y); y-=20;
  }
  const sus=Object.keys(s).filter(k=>s[k]);
  if(sus.length){ x.fillStyle=THEME.colors.sustainText; x.shadowColor=THEME.colors.sustainShadow; x.font=THEME.fonts.listStatus; x.fillText('Sustain:'+sus.map(k=>k.toUpperCase()).join(' '),10,y); y-=20; }
  const playing=Object.keys(o).filter(k=>o[k]&&o[k].assigned&&!s[k]);
 // if(playing.length){ x.fillStyle=THEME.colors.active; x.shadowColor=THEME.colors.active; x.font=THEME.fonts.listStatus; x.fillText('♪ '+playing.map(k=>k.toUpperCase()).join(' '),10,y); y-=20; }
  const ak=Object.keys(m);
  if(ak.length){ x.font=THEME.fonts.allKeys; x.fillText('Keys: '+ak.map(k=>k.toUpperCase()).join(' '),10,y); y-=20; }
  
  if(audioReady) {
    x.fillStyle=THEME.colors.default; x.shadowColor=THEME.colors.default;
  }
  
  if(help){
    x.save();
    x.textAlign='center';
    const hx=W/2, hy=H/2-140;
    const lines=[
      'HELP', '',
      'A-Z/0-9 + MOVE = ASSIGN PITCH', 'CLICK NODE = SELECT / DRAG',
      'TAB = CYCLE EDIT MODE (OSC/ADSR/FILTER/FX/MOD)',
      'ARROW UP/DOWN/SCROLL = CHANGE PARAMETER VALUE', 'ARROW LEFT/RIGHT = CHANGE PARAMETER TYPE',
      'SPACE = SUSTAIN PITCH', 'BACKSPACE = DELETE', 'ESC = STOP ALL + CLEAR',
      'RIGHT CLICK = REMOVE PITCH', 'CTRL/CMD + A = SELECT ALL', 'SHIFT + F = FULLSCREEN','',
    ];
    lines.forEach((line,i)=>{
      x.shadowBlur=THEME.shadows.blurHelp;
      x.fillStyle = THEME.colors.helpText;
      x.shadowColor = THEME.colors.helpText;
      x.font = THEME.fonts.helpFont;
      x.fillText(line,hx,hy+i*25);
          const linkY = hy + (lines.length + 1) * 25;
            const linkText = '→ SEE FULL DOCUMENTATION';
            const textWidth = x.measureText(linkText).width;
            helpLink.style.display = 'block';
            helpLink.style.top = `${linkY - 8}px`;
            helpLink.style.left = `${hx - textWidth / 2}px`;
    });
    x.restore();
  } else {
    helpLink.style.display = 'none';
  }
}
r();

document.addEventListener('keydown',e=>{ if(e.key==='F'&&e.shiftKey&&!e.repeat)c.requestFullscreen(); });
</script>
</body>
</html>