<!DOCTYPE html>
<html>
<head>
<style>
*{margin:0;padding:0;cursor:none}
body{background:#000;overflow:hidden}
canvas{display:block;width:100vw;height:100vh}
#h{position:fixed;top:10px;right:10px;z-index:2;user-select:none; color: #0f0; font: 20px monospace; text-shadow: 0 0 10px #0f0;}
#help-link {
    display: none;
    position: absolute;
    color: #0cf;
    font: 14px monospace;
    text-decoration: none;
    text-shadow: 0 0 10px #0cf;
    z-index: 3;
}
#help-link:hover {
    color: #fff;
    text-shadow: 0 0 15px #fff;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="h">?</div>
<a id="help-link" href="help.html" target="_blank">â†’ SEE FULL DOCUMENTATION</a>
<script>
const helpLink = document.getElementById('help-link');
// ===================
// STYLE CONFIGURATION
// ===================
const THEME = {
    colors: {
        background: '#000',
        default: '#0f0',
        selection: '#0ff',
        active: '#f90',
        sustain: '#0f0',
        sustainText: '#0f0',
        sustainShadow: '#0f0',
        innerSelection: '#0df',
        msgInactive: '#f00',
        msgActive: '#0f0',
        emptyNode: '#666',
        grid: 'rgba(0,255,0,0.05)',
        textKey: '#fff',
        editMode: '#f00',
        editModeText: '#0ff',
        previewFill: 'rgba(0, 204, 255, 0.05)',
        backgroundFade: 'rgba(0,0,0,0.08)',
        helpLinkHover: '#fff',
        helpText: '#0f0',
        helpTextHighlight: '#0cf',
        scaleNote: 'rgba(0,255,255,0.4)',
        scaleGrid: 'rgba(0,255,255,0.15)',
    },
    fonts: {
        helpButton: '20px monospace',
        connectionMsg: 'bold 24px monospace',
        docLink: '14px monospace',
        nodeKey: 'bold 20px monospace',
        nodeHz: '12px monospace',
        cursorHz: '15px monospace',
        editMode: '18px monospace',
        previewStatus: '15px monospace',
        playingStatus: '15px monospace',
        listStatus: '20px monospace',
        allKeys: '15px monospace',
        helpFont: '14px monospace',
        scaleNote: '10px monospace',
        hexNote: '10px monospace'
    },
    shadows: {
        blurDefault: 2,
        blurNode: 15,
        blurNodeActive: 30,
        blurNodeSelected: 15,
        blurConnectionMsg: 30,
        blurHelp: 0.25,
        blurScale: 10
    }
};


// Setup
const a=new AudioContext(),
A=a.createAnalyser(),
g=a.createGain(),
c=document.getElementById('c'),
x=c.getContext('2d');

let W=c.width=innerWidth,
H=c.height=innerHeight;

// Apply initial styles from THEME object
document.body.style.backgroundColor = THEME.colors.background;
const hDiv = document.getElementById('h');
hDiv.style.color = THEME.colors.default;
hDiv.style.font = THEME.fonts.helpButton;
hDiv.style.textShadow = `0 0 ${THEME.shadows.blurDefault}px ${THEME.colors.default}`;


A.fftSize=2048;
g.connect(A);
A.connect(a.destination);
g.gain.value=0.3;

// State
const o={}, m={}, p={}, s={}, e={}, sel={},
      d=new Uint8Array(A.frequencyBinCount);

// Default settings for new nodes
const defaultNodeProps = {
    type: 'sine',
    vol: 0.4,
    attack: 0.01,
    decay: 0.1,
    sustain: 0.5,
    release: 0.5,
    filterType: 'lowpass',
    filterFreq: 20000,
    filterQ: 1,
    distortionAmount: 0,
    reverbWet: 0,
    echoMix: 0,
    echoFeedback: 0,
    tremoloDepth: 0,
    pan: 0,
    lfoRate: 5,
    lfoDepth: 0,
    lfoTarget: 'FILTER'
};

const EDIT_MODES = ['OSC', 'ADSR', 'FILTER', 'FX', 'MOD', 'SCALE', 'SPACE'];
const OSC_PARAMS = ['TYPE', 'VOL'];
const OSC_TYPES=['sine','triangle','square','sawtooth'];
const ADSR_PARAMS = ['ATTACK', 'DECAY', 'SUSTAIN', 'RELEASE'];
const FILTER_PARAMS = ['TYPE', 'FREQ', 'Q'];
const FILTER_TYPES = ['lowpass', 'highpass', 'bandpass', 'notch'];
const FX_PARAMS = ['DISTORT', 'REVERB', 'ECHO_MIX', 'ECHO_FDBK', 'TREMOLO', 'PAN'];
const MOD_PARAMS = ['TARGET', 'RATE', 'DEPTH'];
const MOD_TARGETS = ['FILTER', 'PITCH'];
const SCALE_PARAMS = ['SCALE', 'ROOT'];

// ===================
// SPATIAL MAPPING
// ===================
const SPACE_MODES = ['LOGARITHMIC', 'TONNETZ', 'CIRCULAR', 'UPSPIRAL', 'DOWNSPIRAL'];
let spaceModeIndex = 0;

const F_LOGARITHMIC = (x, y) => Math.pow(2, (x / W * 4)) * 55 * Math.pow(2, 1 - y / H * 3);

const getTonnetzNoteAndPos = (px, py) => {
    const hexSize = Math.min(W / 20, H / 15);
    const hexWidth = Math.sqrt(3) * hexSize;
    const hexHeight = 2 * hexSize * 3/4;
    const q_float = (px - W/2) / hexWidth;
    const r_float = (py - H/2) / hexHeight - ( (Math.round((py - H/2)/hexHeight)) % 2 === 0 ? 0 : 0.5);
    const q = Math.round(q_float);
    const r = Math.round(r_float);
    const rootNote = 60;
    const fifthStep = 7, majorThirdStep = 4;
    let midiNote = rootNote + r * fifthStep;
    if (r % 2 !== 0) midiNote += (q - 0.5) * majorThirdStep;
    else midiNote += q * majorThirdStep;
    const centerX = q * hexWidth + (r % 2) * (hexWidth / 2) + W/2;
    const centerY = r * hexHeight + H/2;
    return { midi: Math.round(midiNote), x: centerX, y: centerY };
};

const F_TONNETZ = (px, py) => {
    const hexSize = Math.min(W / 20, H / 15);
    const hexWidth = Math.sqrt(3) * hexSize;
    const hexHeight = 2 * hexSize * 3/4;
    const q_approx = (px - W/2) / hexWidth, r_approx = (py - H/2) / hexHeight;
    let centers = [];
    for(let r_off = -1; r_off <= 1; r_off++) {
        for(let q_off = -1; q_off <= 1; q_off++) {
            const q = Math.round(q_approx + q_off), r = Math.round(r_approx + r_off);
            centers.push({x: q * hexWidth + (r % 2) * (hexWidth / 2) + W/2, y: r * hexHeight + H/2});
        }
    }
    centers.sort((a,b) => (Math.hypot(a.x-px, a.y-py) - Math.hypot(b.x-px, b.y-py)));
    const nearest3 = centers.slice(0, 3);
    let totalWeight = 0, weightedFreqSum = 0;
    nearest3.forEach(center => {
        let dist = Math.hypot(center.x - px, center.y - py);
        if (dist < 0.001) dist = 0.001;
        const weight = 1 / Math.pow(dist, 2);
        const midi = getTonnetzNoteAndPos(center.x, center.y).midi;
        const freq = 440 * Math.pow(2, (midi - 69) / 12);
        totalWeight += weight;
        weightedFreqSum += freq * weight;
    });
    if (totalWeight === 0) return F_LOGARITHMIC(px, py);
    return weightedFreqSum / totalWeight;
};

const F_CIRCULAR = (x, y) => {
    const centerX = W / 2, centerY = H / 2;
    const dx = x - centerX, dy = y - centerY;
    const radius = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx);
    const maxRadius = Math.min(centerX, centerY);
    const octave = (radius / maxRadius) * 6;
    const noteInOctave = (angle + Math.PI) / (2 * Math.PI) * 12;
    const midiNote = 12 * octave + noteInOctave + 12;
    return 440 * Math.pow(2, (midiNote - 69) / 12);
};

const F_SPIRAL = (x, y, isUp = true) => {
    const centerX = W / 2, centerY = H / 2;
    const dx = x - centerX, dy = y - centerY;
    const angle = Math.atan2(dy, dx), radius = Math.sqrt(dx * dx + dy * dy);
    const maxRadius = Math.min(centerX, centerY) * 1.5, turns = 5;
    let continuousNote = (angle / (2 * Math.PI)) * 12;
    const octaveFromRadius = (radius / maxRadius) * (12 * turns);
    if (isUp) {
        continuousNote += octaveFromRadius;
        return 440 * Math.pow(2, (continuousNote + 24 - 69) / 12);
    } else {
        continuousNote -= octaveFromRadius;
        return 440 * Math.pow(2, (continuousNote + 96 - 69) / 12);
    }
};

const F_UPSPIRAL = (x, y) => F_SPIRAL(x, y, true);
const F_DOWNSPIRAL = (x, y) => F_SPIRAL(x, y, false);

const F_MAPS = [F_LOGARITHMIC, F_TONNETZ, F_CIRCULAR, F_UPSPIRAL, F_DOWNSPIRAL];
const F = (x, y) => F_MAPS[spaceModeIndex](x, y);

// Scale definitions
const SCALE_PRESETS = { 'CHROMATIC': 4095, 'MAJOR': 2741, 'MINOR': 2905, 'DORIAN': 2901, 'PHRYGIAN': 3417, 'LYDIAN': 2733, 'MIXOLYDIAN': 2709, 'AEOLIAN': 2905, 'LOCRIAN': 3433, 'PENTATONIC': 2385, 'BLUES': 3505, 'HARMONIC_MIN': 2777, 'MELODIC_MIN': 2773, 'WHOLE_TONE': 1365, 'DIMINISHED': 2340, 'AUGMENTED': 585 };
const SCALE_NAMES = Object.keys(SCALE_PRESETS);
let currentScaleIndex = 1, currentScaleRoot = 0;
const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

const numberToScale = (number = 4095) => {
    const binaryString = (number >>> 0).toString(2).padStart(12, '0');
    return binaryString.split('').map((bit, i) => (bit === '1' ? 11 - i : -1)).filter(n => n !== -1).reverse();
};

const freqToNote = (freq) => {
    const A4 = 440;
    const semitones = 12 * Math.log2(freq / A4);
    const noteNum = Math.round(semitones) + 69;
    const octave = Math.floor(noteNum / 12) - 1;
    const noteIndex = noteNum % 12;
    return { name: NOTE_NAMES[noteIndex], octave, noteIndex, midi: noteNum };
};

const isInScale = (freq) => {
    const note = freqToNote(freq);
    const scalePattern = numberToScale(SCALE_PRESETS[SCALE_NAMES[currentScaleIndex]]);
    const relativeNote = (note.noteIndex - currentScaleRoot + 12) % 12;
    return scalePattern.includes(relativeNote);
};

// ===================
// GRID DRAWING
// ===================

const drawLogarithmicGrid = () => {
    x.strokeStyle=THEME.colors.grid; x.lineWidth=1; x.shadowBlur=0;
    for(let i=1;i<10;i++){ x.beginPath(); x.moveTo(i*W/10,0); x.lineTo(i*W/10,H); x.stroke(); }
    for(let i=1;i<8;i++){ x.beginPath(); x.moveTo(0,i*H/8); x.lineTo(W,i*H/8); x.stroke(); }
};

const drawHexagon = (px, py, size) => {
    x.beginPath();
    for (let i = 0; i < 6; i++) x.lineTo(px + size * Math.cos(Math.PI / 3 * i + Math.PI / 6), py + size * Math.sin(Math.PI / 3 * i + Math.PI / 6));
    x.closePath();
};

const drawTonnetzGrid = () => {
    const hexSize = Math.min(W / 20, H / 15);
    const hexWidth = Math.sqrt(3) * hexSize, hexHeight = 2 * hexSize * 3/4;
    x.strokeStyle = THEME.colors.grid; x.lineWidth = 0.5; x.shadowBlur = 0;
    const cols = Math.ceil(W / hexWidth) + 2, rows = Math.ceil(H / hexHeight) + 2;
    for (let row = -1; row < rows; row++) {
        for (let col = -1; col < cols; col++) {
            const px = col * hexWidth + (row % 2) * (hexWidth / 2) + W/2 - hexWidth/2;
            const py = row * hexHeight + H/2 - hexHeight/2;
            drawHexagon(px, py, hexSize); x.stroke();
        }
    }
};

const drawCircularGrid = () => {
    const centerX = W/2, centerY = H/2, maxRadius = Math.min(centerX, centerY) * 0.95;
    x.strokeStyle = THEME.colors.grid; x.lineWidth = 0.5; x.shadowBlur = 0;
    for (let i = 0; i < 12; i++) { const angle = (i / 12) * 2 * Math.PI; x.beginPath(); x.moveTo(centerX, centerY); x.lineTo(centerX + Math.cos(angle) * maxRadius, centerY + Math.sin(angle) * maxRadius); x.stroke(); }
    for (let i = 1; i <= 6; i++) { const radius = (i / 6) * maxRadius; x.beginPath(); x.arc(centerX, centerY, radius, 0, 2 * Math.PI); x.stroke(); }
};

const drawSpiralGrid = () => {
    const centerX = W/2, centerY = H/2;
    x.strokeStyle = THEME.colors.grid; x.lineWidth = 0.5; x.shadowBlur = 0;
    x.beginPath();
    const turns = 5, maxRadius = Math.min(centerX, centerY) * 1.5;
    for (let i = 0; i < turns * 360; i++) {
        const angle = i * Math.PI / 180, radius = maxRadius * (angle / (turns * 2 * Math.PI));
        const px = centerX + radius * Math.cos(angle), py = centerY + radius * Math.sin(angle);
        i === 0 ? x.moveTo(px, py) : x.lineTo(px, py);
    }
    x.stroke();
};

const GRID_DRAWERS = [drawLogarithmicGrid, drawTonnetzGrid, drawCircularGrid, drawSpiralGrid, drawSpiralGrid];
const drawSpaceGrid = () => GRID_DRAWERS[spaceModeIndex]();

const drawScaleOverlay = () => {
    if (EDIT_MODES[editModeIndex] !== 'SCALE') return;
    const scalePattern = numberToScale(SCALE_PRESETS[SCALE_NAMES[currentScaleIndex]]);
    const currentSpaceMode = SPACE_MODES[spaceModeIndex];

    if (currentSpaceMode === 'TONNETZ') {
        const hexSize = Math.min(W / 20, H / 15), hexWidth = Math.sqrt(3) * hexSize, hexHeight = 2 * hexSize * 3/4;
        const cols = Math.ceil(W / hexWidth) + 2, rows = Math.ceil(H / hexHeight) + 2;
        for (let row = -1; row < rows; row++) {
            for (let col = -1; col < cols; col++) {
                const px = col * hexWidth + (row % 2) * (hexWidth / 2) + W/2 - hexWidth/2;
                const py = row * hexHeight + H/2 - hexHeight/2;
                const note = freqToNote(F_TONNETZ(px, py));
                const relativeNote = (note.noteIndex - currentScaleRoot + 12) % 12;
                if (scalePattern.includes(relativeNote)) {
                    x.fillStyle = THEME.colors.scaleNote;
                    x.globalAlpha = (note.noteIndex === currentScaleRoot) ? 0.6 : 0.4;
                    drawHexagon(px, py, hexSize); x.fill();
                    x.globalAlpha = 1;
                    x.fillStyle = THEME.colors.textKey;
                    x.font = THEME.fonts.hexNote;
                    x.textAlign = 'center'; x.textBaseline = 'middle';
                    x.fillText(`${note.name}${note.octave}`, px, py);
                }
            }
        }
    }
};

let mx=W/2,my=H/2,t=0,hk=null,md=0,pv=null,pk=new Set(),esc=0,ei=0,help=0,
    drag=null,dragOff={x:0,y:0}, editModeIndex = 0,
    paramIndices = { OSC: 0, ADSR: 0, FILTER: 0, FX: 0, MOD: 0, SCALE: 0, SPACE: 0 },
    heldKeys = {}, audioReady = false, connectionMsg = 'Click to Connect';

(async function createImpulse() {
    const sampleRate = a.sampleRate, length = sampleRate * 1.5;
    impulseBuffer = a.createBuffer(2, length, sampleRate);
    const impulseL = impulseBuffer.getChannelData(0), impulseR = impulseBuffer.getChannelData(1);
    for (let i = 0; i < length; i++) { const decay = Math.pow(1 - i / length, 2.5); impulseL[i] = (Math.random() * 2 - 1) * decay; impulseR[i] = (Math.random() * 2 - 1) * decay; }
})();

onresize=()=>{
  const relPos={}, relEmpty={};
  Object.keys(p).forEach(k=>{ relPos[k]={x:p[k].x/W,y:p[k].y/H}; });
  Object.keys(e).forEach(k=>{ relEmpty[k]={x:e[k].x/W,y:e[k].y/H}; });
  W=c.width=innerWidth; H=c.height=innerHeight;
  Object.keys(relPos).forEach(k=>{ p[k]={...p[k], x:relPos[k].x*W, y:relPos[k].y*H}; m[k]=F(p[k].x,p[k].y); });
  Object.keys(relEmpty).forEach(k=>{ e[k]={x:relEmpty[k].x*W,y:relEmpty[k].y*H,f:F(relEmpty[k].x*W,relEmpty[k].y*H)}; });
  mx=mx/innerWidth*W; my=my/innerHeight*H;
};

function makeDistortionCurve(amount) {
  const k = typeof amount === 'number' ? amount : 50, n_samples = 44100, curve = new Float32Array(n_samples), deg = Math.PI / 180;
  for (let i = 0; i < n_samples; ++i) { const x = i * 2 / n_samples - 1; curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x)); }
  return curve;
};

const createAudioNodes=(f,x,y, nodeProps)=>{
  const now = a.currentTime, np = {...defaultNodeProps, ...nodeProps};
  const v = a.createGain(); v.gain.setValueAtTime(0, now);
  const osc = a.createOscillator(); osc.frequency.value = f; osc.type = np.type;
  const filter = a.createBiquadFilter(); filter.type = np.filterType; filter.frequency.value = np.filterFreq; filter.Q.value = np.filterQ;
  const distortion = a.createWaveShaper(); distortion.curve = makeDistortionCurve(np.distortionAmount); distortion.oversample = '4x';
  const convolver = a.createConvolver(); convolver.buffer = impulseBuffer;
  const reverbWet = a.createGain(); reverbWet.gain.value = np.reverbWet;
  const delay = a.createDelay(1.0); delay.delayTime.value = 0.5;
  const feedback = a.createGain(); feedback.gain.value = np.echoFeedback;
  const echoMix = a.createGain(); echoMix.gain.value = np.echoMix;
  const tremoloLFO = a.createOscillator(); tremoloLFO.frequency.value = np.lfoRate;
  const tremoloDepth = a.createGain(); tremoloDepth.gain.value = np.tremoloDepth;
  tremoloLFO.connect(tremoloDepth).connect(v.gain); tremoloLFO.start();
  const modLFO = a.createOscillator(); modLFO.frequency.value = np.lfoRate;
  const modDepth = a.createGain(); modDepth.gain.value = np.lfoDepth;
  modLFO.connect(modDepth);
  if (np.lfoTarget === 'FILTER') modDepth.connect(filter.frequency); 
  else if (np.lfoTarget === 'PITCH') modDepth.connect(osc.frequency);
  modLFO.start();
  const panner = a.createStereoPanner(); panner.pan.value = np.pan !== 0 ? np.pan : (x / W - 0.5) * 2;
  osc.connect(filter).connect(distortion);
  distortion.connect(panner);
  distortion.connect(convolver).connect(reverbWet).connect(panner);
  distortion.connect(delay);
  delay.connect(feedback).connect(delay);
  delay.connect(echoMix).connect(panner);
  panner.connect(v).connect(g);
  osc.start();
  v.gain.linearRampToValueAtTime(np.vol, now + np.attack);
  v.gain.linearRampToValueAtTime(np.sustain * np.vol, now + np.attack + np.decay);
  return {s:osc,v,p:panner,f,filter,distortion,reverbWet,delay,feedback,echoMix,tremoloLFO,tremoloDepth, modLFO, modDepth};
};

const stopOsc=(osc, releaseTime)=>{
  if(!osc || !osc.v) return;
  const release = releaseTime !== undefined ? releaseTime : defaultNodeProps.release;
  const now = a.currentTime;
  osc.v.gain.cancelScheduledValues(now);
  osc.v.gain.setValueAtTime(osc.v.gain.value, now);
  osc.v.gain.linearRampToValueAtTime(0.0001, now + release);
  setTimeout(()=> { if (osc.s) { osc.s.stop(); osc.s.disconnect(); } }, (release + 0.1) * 1000);
};

const stopAll = () => {
    Object.keys(o).forEach(k => { if (o[k]) { stopOsc(o[k], p[k]?.release || defaultNodeProps.release); delete o[k]; } });
    Object.keys(s).forEach(k => delete s[k]);
};

onmousemove=e=>{
  mx=e.clientX; my=e.clientY;
  if(drag){
    Object.keys(sel).forEach(k=>{
        if(sel[k] && p[k]){
            let newX, newY;
            if(k === drag) { newX = mx; newY = my; } 
            else { const offset = dragOff.nodes[k]; newX = offset ? mx + offset.x : p[k].x; newY = offset ? my + offset.y : p[k].y; }
            p[k].x = newX; p[k].y = newY; m[k] = F(newX, newY);
            if(o[k] && o[k].s){ o[k].s.frequency.exponentialRampToValueAtTime(m[k], a.currentTime + 0.05); o[k].p.pan.value = p[k].pan || (newX / W - 0.5) * 2; }
        }
    });
    return;
  }
  if(hk&&o[hk]&&!o[hk].assigned){ const f=F(mx,my); o[hk].s.frequency.exponentialRampToValueAtTime(f,a.currentTime+0.05); o[hk].p.pan.value=(mx/W-0.5)*2; o[hk].f=f; o[hk].mx=mx; o[hk].my=my; }
  if(md&&pv){ const f=F(mx,my); pv.s.frequency.exponentialRampToValueAtTime(f,a.currentTime+0.05); pv.p.pan.value=(mx/W-0.5)*2; pv.mx=mx; pv.my=my; pv.f=f; }
};

onmousedown=e=>{
  if (!audioReady) { a.resume(); audioReady = true; connectionMsg = null; }
  if(e.button===2) return;
  mx=e.clientX; my=e.clientY;
  if(help){ help=false; return; }
  let clicked=false;
  Object.keys(p).forEach(k=>{
    const {x:kx,y:ky}=p[k];
    if(Math.sqrt((mx-kx)**2+(my-ky)**2)<25){
      clicked=true;
      if(!sel[k]&&!e.shiftKey&&!e.ctrlKey&&!e.metaKey) Object.keys(sel).forEach(sk=>delete sel[sk]);
      sel[k]=true; drag=k; dragOff={x:mx,y:my,nodes:{}};
      Object.keys(sel).forEach(sk=>{ if(sel[sk] && sk!==k && p[sk]) dragOff.nodes[sk]={x:p[sk].x-mx,y:p[sk].y-my}; });
    }
  });
  if(!clicked) Object.keys(e).forEach(id=>{ const {x:ex,y:ey}=e[id]; if(Math.sqrt((mx-ex)**2+(my-ey)**2)<25){ clicked=true; delete e[id]; } });
  if(!clicked){
    if(!e.shiftKey&&!e.ctrlKey&&!e.metaKey) Object.keys(sel).forEach(k=>delete sel[k]);
    md=1; const f=F(mx,my); const audioNodes=createAudioNodes(f,mx,my, defaultNodeProps); pv={...audioNodes,mx,my,f};
  }
};

onmouseup=e=>{
  if(e.button===2) return;
  if(drag){ drag=null; dragOff={x:0,y:0}; return; }
  md=0;
  if(pv&&!pv.assigned){
    const emptyKeys=Object.keys(e);
    if(emptyKeys.length>0&&!pv.wasKey) e[emptyKeys[emptyKeys.length-1]]={x:pv.mx,y:pv.my,f:F(pv.mx,pv.my)};
    else e['e'+(ei++)]={x:pv.mx,y:pv.my,f:F(pv.mx,pv.my)};
    if(!pv.keepAlive) { stopOsc(pv, defaultNodeProps.release); pv=null; }
  } else if(pv&&!pv.keepAlive){ stopOsc(pv, defaultNodeProps.release); pv=null; }
};

oncontextmenu=e=>{
  e.preventDefault();
  Object.keys(p).forEach(k=>{
    const {x:kx,y:ky}=p[k];
    if(Math.sqrt((e.clientX-kx)**2+(e.clientY-ky)**2)<25){
      if(o[k]){ stopOsc(o[k], p[k]?.release || defaultNodeProps.release); delete o[k]; }
      delete m[k]; delete p[k]; delete s[k]; delete sel[k];
    }
  });
};

function handleValueChange(direction) {
    const mode = EDIT_MODES[editModeIndex];
    const selKeys = Object.keys(sel).filter(key => sel[key]);

    const targets = selKeys.length > 0 ? selKeys.map(k => p[k]) : [defaultNodeProps];
    const liveNodes = selKeys.length > 0 ? selKeys.map(k => o[k]).filter(Boolean) : (pv ? [pv] : []);

    targets.forEach((props, i) => {
        if (!props) return;
        const liveNode = liveNodes[i];
        const paramIndex = paramIndices[mode];

        if (mode === 'SCALE') {
            if (paramIndex === 0) currentScaleIndex = (currentScaleIndex + direction + SCALE_NAMES.length) % SCALE_NAMES.length;
            else if (paramIndex === 1) currentScaleRoot = (currentScaleRoot + direction + 12) % 12;
        } else if (mode === 'OSC') {
            if (paramIndex === 0) { // TYPE
                const typeIndex = OSC_TYPES.indexOf(props.type || 'sine');
                props.type = OSC_TYPES[(typeIndex + direction + OSC_TYPES.length) % OSC_TYPES.length];
                if (liveNode && liveNode.s) liveNode.s.type = props.type;
            } else if (paramIndex === 1) { // VOL
                props.vol = Math.max(0, Math.min(1, (props.vol || 0.4) + direction * 0.01));
                if (liveNode && liveNode.v) liveNode.v.gain.linearRampToValueAtTime(props.vol, a.currentTime + 0.02);
            }
        } else if (mode === 'FILTER') {
             if (paramIndex === 0) { // TYPE
                const typeIndex = FILTER_TYPES.indexOf(props.filterType || 'lowpass');
                props.filterType = FILTER_TYPES[(typeIndex + direction + FILTER_TYPES.length) % FILTER_TYPES.length];
                if (liveNode && liveNode.filter) liveNode.filter.type = props.filterType;
            } else if (paramIndex === 1) { // FREQ
                props.filterFreq = (props.filterFreq || 20000) * (direction > 0 ? 1.05 : 1/1.05);
                props.filterFreq = Math.max(20, Math.min(20000, props.filterFreq));
                if (liveNode && liveNode.filter) liveNode.filter.frequency.linearRampToValueAtTime(props.filterFreq, a.currentTime + 0.02);
            } else if (paramIndex === 2) { // Q
                props.filterQ = Math.max(0.001, Math.min(20, (props.filterQ || 1) + direction * 0.1));
                if (liveNode && liveNode.filter) liveNode.filter.Q.linearRampToValueAtTime(props.filterQ, a.currentTime + 0.02);
            }
        } else if (mode === 'ADSR') {
            const param = ADSR_PARAMS[paramIndex];
            const key = param.toLowerCase();
            props[key] = Math.max(0.001, (props[key] || defaultNodeProps[key]) + direction * (param === 'SUSTAIN' ? 0.01 : 0.05));
            if(param === 'SUSTAIN') props[key] = Math.min(1, props[key]);
        } else if (mode === 'FX') {
            const param = FX_PARAMS[paramIndex];
            if(param === 'DISTORT') {
                props.distortionAmount = Math.max(0, (props.distortionAmount || 0) + direction * 10);
                if (liveNode && liveNode.distortion) liveNode.distortion.curve = makeDistortionCurve(props.distortionAmount);
            } else if(param === 'REVERB') {
                props.reverbWet = Math.max(0, Math.min(1, (props.reverbWet || 0) + direction * 0.02));
                if (liveNode && liveNode.reverbWet) liveNode.reverbWet.gain.linearRampToValueAtTime(props.reverbWet, a.currentTime + 0.02);
            } else if(param === 'ECHO_MIX') {
                props.echoMix = Math.max(0, Math.min(1, (props.echoMix || 0) + direction * 0.02));
                if (liveNode && liveNode.echoMix) liveNode.echoMix.gain.linearRampToValueAtTime(props.echoMix, a.currentTime + 0.02);
            } else if(param === 'ECHO_FDBK') {
                props.echoFeedback = Math.max(0, Math.min(0.95, (props.echoFeedback || 0) + direction * 0.02));
                if (liveNode && liveNode.feedback) liveNode.feedback.gain.linearRampToValueAtTime(props.echoFeedback, a.currentTime + 0.02);
            } else if(param === 'TREMOLO') {
                props.tremoloDepth = Math.max(0, Math.min(1, (props.tremoloDepth || 0) + direction * 0.02));
                if (liveNode && liveNode.tremoloDepth) liveNode.tremoloDepth.gain.linearRampToValueAtTime(props.tremoloDepth * props.vol, a.currentTime + 0.02);
            } else if(param === 'PAN') {
                props.pan = Math.max(-1, Math.min(1, (props.pan || 0) + direction * 0.05));
                if (liveNode && liveNode.p) liveNode.p.pan.linearRampToValueAtTime(props.pan, a.currentTime + 0.02);
            }
        } else if (mode === 'MOD') {
            if (paramIndex === 0) { // TARGET
                const targetIndex = MOD_TARGETS.indexOf(props.lfoTarget || 'FILTER');
                props.lfoTarget = MOD_TARGETS[(targetIndex + direction + MOD_TARGETS.length) % MOD_TARGETS.length];
            } else if (paramIndex === 1) { // RATE
                props.lfoRate = Math.max(0.1, (props.lfoRate || 5) + direction * 0.5);
                if (liveNode && liveNode.modLFO) liveNode.modLFO.frequency.linearRampToValueAtTime(props.lfoRate, a.currentTime + 0.02);
            } else if (paramIndex === 2) { // DEPTH
                props.lfoDepth = Math.max(0, (props.lfoDepth || 0) + direction * 5);
                if (liveNode && liveNode.modDepth) liveNode.modDepth.gain.linearRampToValueAtTime(props.lfoDepth, a.currentTime + 0.02);
            }
        }
    });
}

onwheel = e => { e.preventDefault(); handleValueChange(e.deltaY < 0 ? 1 : -1); };

onkeydown=e=>{
  const k=e.key;
  if (e.repeat && (k !== 'ArrowUp' && k !== 'ArrowDown')) return;
  
  const currentEditMode = EDIT_MODES[editModeIndex];
  const arrowDirection = k === 'ArrowRight' ? 1 : (k === 'ArrowLeft' ? -1 : 0);
  const valueDirection = k === 'ArrowUp' ? 1 : (k === 'ArrowDown' ? -1 : 0);

  if (valueDirection !== 0) { handleValueChange(valueDirection); e.preventDefault(); return; }
  
  if (arrowDirection !== 0) {
      if (currentEditMode === 'SCALE') paramIndices.SCALE = (paramIndices.SCALE + arrowDirection + SCALE_PARAMS.length) % SCALE_PARAMS.length;
      else if (currentEditMode === 'SPACE') spaceModeIndex = (spaceModeIndex + arrowDirection + SPACE_MODES.length) % SPACE_MODES.length;
      else if (currentEditMode === 'OSC') paramIndices.OSC = (paramIndices.OSC + arrowDirection + OSC_PARAMS.length) % OSC_PARAMS.length;
      else if (currentEditMode === 'FILTER') paramIndices.FILTER = (paramIndices.FILTER + arrowDirection + FILTER_PARAMS.length) % FILTER_PARAMS.length;
      else if (currentEditMode === 'ADSR') paramIndices.ADSR = (paramIndices.ADSR + arrowDirection + ADSR_PARAMS.length) % ADSR_PARAMS.length;
      else if (currentEditMode === 'FX') paramIndices.FX = (paramIndices.FX + arrowDirection + FX_PARAMS.length) % FX_PARAMS.length;
      else if (currentEditMode === 'MOD') paramIndices.MOD = (paramIndices.MOD + arrowDirection + MOD_PARAMS.length) % MOD_PARAMS.length;
      e.preventDefault(); return;
  }

  if((e.ctrlKey||e.metaKey)&&k==='a'){ e.preventDefault(); Object.keys(p).forEach(key=>{ sel[key]=true; }); return; }
  if(k === 'Tab') { e.preventDefault(); editModeIndex = (editModeIndex + 1) % EDIT_MODES.length; return; }
  if(k==='?'||k==='/'){ e.preventDefault(); help=!help; return; }
  if(k==='Escape'){ e.preventDefault(); esc=1; stopAll(); Object.keys(sel).forEach(k=>delete sel[k]); return; }
  if(k===' '||k==='Space'){
    e.preventDefault();
    const selKeys = Object.keys(sel).filter(key => sel[key]);
    const keysToToggle = selKeys.length ? selKeys : Object.keys(p).filter(key => Math.sqrt((mx-p[key].x)**2+(my-p[key].y)**2)<25);
    keysToToggle.forEach(key=>{
      if(s[key]){ delete s[key]; if(o[key]){ stopOsc(o[key], p[key]?.release); delete o[key]; }}
      else{ s[key]=true; if(!o[key]){ o[key]={...createAudioNodes(m[key],p[key].x,p[key].y, p[key] || {}),assigned:true}; }}
    });
    return;
  }
  if(k==='Backspace'){
    e.preventDefault();
    const selKeys = Object.keys(sel).filter(key => sel[key]);
    selKeys.forEach(key=>{ if(o[key]){ stopOsc(o[key], p[key]?.release); delete o[key]; } delete m[key]; delete p[key]; delete s[k]; delete sel[k]; });
    return;
  }
  const isAlphaNum=/^[a-zA-Z0-9]$/.test(k);
  if(!isAlphaNum) return;
  pk.add(k);
  if(m[k]){ sel[k] = true; if(!o[k]) o[key]={...createAudioNodes(m[k],p[key].x,p[key].y, p[key] || {}),assigned:true}; } 
  else { if(!o[k]){ hk=k; const f=F(mx,my); o[k]={...createAudioNodes(f,mx,my,defaultNodeProps),assigned:false,mx,my,f}; } }
};

onkeyup=e=>{
  const k=e.key;
  if(k==='Escape'){ esc=0; return; }
  if(k===' '||k==='Space'||k==='Backspace'||k==='?'||k==='/'||k.includes('Arrow')||k==='Tab') return;
  delete sel[k]; pk.delete(k);
  if(o[k]){
    if(!o[k].assigned){ m[k]=o[k].f; p[k]={x:o[k].mx||mx,y:o[k].my||my, ...defaultNodeProps}; }
    if(!s[k]){ stopOsc(o[k], p[k]?.release); delete o[k]; }
    if(hk===k) hk=null;
  }
};

document.getElementById('h').onclick=()=>{ help=!help; };

// ===================
// RENDER LOOP
// ===================

function r(){
  requestAnimationFrame(r);
  A.getByteTimeDomainData(d);
  x.fillStyle=THEME.colors.backgroundFade;
  x.fillRect(0,0,W,H);

  drawSpaceGrid();
  drawScaleOverlay();

  if(!audioReady || connectionMsg) {
      x.font = THEME.fonts.connectionMsg; x.textAlign = 'center';
      x.fillStyle = THEME.colors.msgActive; x.shadowColor = x.fillStyle;
      x.shadowBlur = THEME.shadows.blurConnectionMsg;
      x.fillText(connectionMsg || 'Click to Connect', W/2, H/2);
      x.shadowBlur = 0; return;
  }
  
  if(!help){
    Object.keys(e).forEach(id=>{
      const {x:ex,y:ey,f}=e[id];
      x.strokeStyle = THEME.colors.emptyNode; x.shadowBlur = THEME.shadows.blurDefault;
      x.shadowColor = THEME.colors.emptyNode; x.lineWidth=1; x.setLineDash([5,5]);
      x.beginPath(); x.arc(ex,ey,15,0,Math.PI*2); x.stroke(); x.setLineDash([]);
      x.fillStyle = THEME.colors.emptyNode; x.font = THEME.fonts.nodeHz;
      x.textAlign='left'; x.fillText(~~f+'Hz',ex+20,ey+3);
    });

    Object.keys(p).forEach(k=>{
      const {x:kx,y:ky}=p[k];
      const active=o[k]&&o[k].assigned, selected=sel[k], sustained=s[k];
      let color = selected ? THEME.colors.selection : (sustained ? THEME.colors.sustain : THEME.colors.default);
      let radius = 15, lineWidth = 2, shadowBlur = THEME.shadows.blurNode;
      if (active) { shadowBlur = THEME.shadows.blurNodeActive; radius += 2 + Math.sin(t * 6) * 2; lineWidth += 1; }
      if (selected) { shadowBlur = THEME.shadows.blurNodeSelected; lineWidth += 3; }
      x.strokeStyle = color; x.fillStyle = color; x.shadowBlur = shadowBlur; x.shadowColor = color; x.lineWidth = lineWidth;
      x.beginPath(); x.arc(kx, ky, radius, 0, Math.PI * 2); x.stroke();
      x.beginPath(); x.arc(kx, ky, active ? 1 : 3, 0, Math.PI * 2); x.fill();
      x.fillStyle = THEME.colors.textKey; x.font = THEME.fonts.nodeKey;
      x.textAlign='center'; x.textBaseline='middle'; x.fillText(k.toUpperCase(),kx,ky);
      x.fillStyle=color; x.font=THEME.fonts.nodeHz; x.textAlign='left';
      const note = freqToNote(m[k]);
      x.fillText(`${note.name}${note.octave} ${~~m[k]}Hz`,kx+25,ky+3);
    });
  }

  const cf=F(mx,my), cursorNote = freqToNote(cf);
  let cursorColor = (drag || hk || md) ? THEME.colors.selection : THEME.colors.default;
  x.strokeStyle = cursorColor; x.shadowColor = cursorColor; x.shadowBlur = THEME.shadows.blurDefault; x.lineWidth=1;
  
  if (hk || md) {
      x.shadowBlur=THEME.shadows.blurNodeActive; x.lineWidth=2;
      x.beginPath(); x.arc(mx,my, 15,0,Math.PI*2); x.stroke();
  } else {
      x.beginPath(); x.moveTo(mx-15,my); x.lineTo(mx+15,my); x.moveTo(mx,my-15); x.lineTo(mx,my+15); x.stroke();
  }

  if(!help) {
    x.fillStyle=cursorColor; x.font=THEME.fonts.cursorHz;
    x.textAlign='left'; x.fillText(`${cursorNote.name}${cursorNote.octave} ${~~cf}Hz`,mx+20,my-20);
    x.strokeStyle=THEME.colors.default; x.lineWidth=2;
    x.shadowBlur=THEME.shadows.blurNode; x.shadowColor=THEME.colors.default;
    x.beginPath();
    const l=d.length;
    for(let i=0;i<l;i++){ const v=d[i]/128, y=v*H/2, X=i/l*W; i ? x.lineTo(X,y) : x.moveTo(X,y); }
    x.stroke();
  }

  t+=0.015;

  let y=H-20;
  const currentEditMode = EDIT_MODES[editModeIndex];
  x.font = THEME.fonts.editMode; x.fillStyle = THEME.colors.default; x.shadowColor = x.fillStyle;
  x.fillText(`EDIT MODE: ${currentEditMode}`, 10, y); y -= 20;
  
  x.font=THEME.fonts.listStatus;
  const selKeys = Object.keys(sel).filter(key => sel[key]);

  if (selKeys.length === 0) { // Display defaults
      let text = 'Defaults: ';
      const paramIndex = paramIndices[currentEditMode];
      if (currentEditMode === 'SCALE') {
          const scaleText = `Scale: ${SCALE_NAMES[currentScaleIndex]}`;
          const rootText = `Root: ${NOTE_NAMES[currentScaleRoot]}`;
          text += paramIndex === 0 ? `[${scaleText}]` : scaleText;
          text += ' | ';
          text += paramIndex === 1 ? `[${rootText}]` : rootText;
      } else if (currentEditMode === 'SPACE') {
          text = `Spatial Mode: [${SPACE_MODES[spaceModeIndex]}]`;
      } else if (currentEditMode === 'OSC') {
          const typeText = `Type: ${defaultNodeProps.type.toUpperCase()}`;
          const volText = `Vol: ${~~(defaultNodeProps.vol * 100)}%`;
          text += paramIndex === 0 ? `[${typeText}]` : typeText;
          text += ' | ';
          text += paramIndex === 1 ? `[${volText}]` : volText;
      } else if (currentEditMode === 'ADSR') {
          text += ADSR_PARAMS.map((p,i) => {
              const val = defaultNodeProps[p.toLowerCase()].toFixed(2);
              return i === paramIndex ? `[${p}:${val}]` : `${p}:${val}`;
          }).join(' | ');
      } else if (currentEditMode === 'FILTER') {
          const typeText = `Type: ${defaultNodeProps.filterType.toUpperCase()}`;
          const freqText = `Freq: ${~~defaultNodeProps.filterFreq}Hz`;
          const qText = `Q: ${defaultNodeProps.filterQ.toFixed(2)}`;
          text += paramIndex === 0 ? `[${typeText}]` : typeText;
          text += ' | ';
          text += paramIndex === 1 ? `[${freqText}]` : freqText;
          text += ' | ';
          text += paramIndex === 2 ? `[${qText}]` : qText;
      } else if (currentEditMode === 'FX') {
          text += FX_PARAMS.map((p, i) => {
              let val = '';
              if (p === 'DISTORT') val = `${~~(defaultNodeProps.distortionAmount / 10)}%`;
              else if (p === 'REVERB') val = `${~~(defaultNodeProps.reverbWet * 100)}%`;
              else if (p === 'ECHO_MIX') val = `${~~(defaultNodeProps.echoMix * 100)}%`;
              else if (p === 'ECHO_FDBK') val = `${~~(defaultNodeProps.echoFeedback * 100)}%`;
              else if (p === 'TREMOLO') val = `${~~(defaultNodeProps.tremoloDepth * 100)}%`;
              else if (p === 'PAN') val = `${~~(defaultNodeProps.pan * 100)}%`;
              const paramText = `${p}:${val}`;
              return i === paramIndex ? `[${paramText}]` : paramText;
          }).join(' | ');
      } else if (currentEditMode === 'MOD') {
          const targetText = `Target: ${defaultNodeProps.lfoTarget}`;
          const rateText = `Rate: ${defaultNodeProps.lfoRate.toFixed(1)}Hz`;
          const depthText = `Depth: ${defaultNodeProps.lfoDepth.toFixed(0)}`;
          text += paramIndex === 0 ? `[${targetText}]` : targetText;
          text += ' | ';
          text += paramIndex === 1 ? `[${rateText}]` : rateText;
          text += ' | ';
          text += paramIndex === 2 ? `[${depthText}]` : depthText;
      }
      x.fillText(text, 10, y); y -= 20;
  }
  
  if(help){
    x.save(); x.textAlign='center';
    const hx=W/2, hy=H/2-180;
    const lines=[
      'HELP', '', 'TAB = Cycle Edit Mode', 'ARROWS = Navigate & Change Parameters', '',
      'SPACE MODE: LEFT/RIGHT = Change Mapping', '',
      'SCALE MODE: LEFT/RIGHT = Select Param | UP/DOWN = Change Value', '',
      'A-Z/0-9 + MOVE = Assign Pitch', 'CLICK/DRAG = Select/Move',
      'SPACE = Sustain', 'BACKSPACE = Delete', 'RIGHT CLICK = Remove', 'ESC = STOP ALL'
    ];
    lines.forEach((line,i)=>{
      x.shadowBlur=THEME.shadows.blurHelp; x.fillStyle = THEME.colors.helpText;
      x.shadowColor = THEME.colors.helpText; x.font = THEME.fonts.helpFont;
      x.fillText(line,hx,hy+i*25);
    });
    const linkY = hy + (lines.length + 1) * 25, linkText = 'â†’ SEE FULL DOCUMENTATION';
    const textWidth = x.measureText(linkText).width;
    helpLink.style.display = 'block'; helpLink.style.top = `${linkY - 8}px`;
    helpLink.style.left = `${hx - textWidth / 2}px`;
    x.restore();
  } else {
    helpLink.style.display = 'none';
  }
}
r();

document.addEventListener('keydown',e=>{ if(e.key==='F'&&e.shiftKey&&!e.repeat) c.requestFullscreen(); });
</script>
</body>
</html>
